---
title: "Cycle Data Pre-processing"
author: "Myeong Lee"
date: "7/22/2017"
output: html_document
---

This script pre-processes the cycle sensors data so that they can be used as features and classifiers.
Pre-processing includes (1) converting the time domain to the distance domain, (2) interpolating missing values in the distance domain, (3) resampling variables based on the distances, and (4) appling the Gaussian filter to the signal to minimize the noise. 

```{r}
library(jsonlite)
library(readr)
library(dplyr)
library(sp)
library(ggplot2)
library(ggmap)
library(dplyr)
library(tidyr)
library(geosphere)
library(scales)
library(smoother)
library(dtt)
library(e1071)
library(stringr)
library(randomForest)

setwd("/Users/myeong/git/Atl_DSSG/Cycle-Atlanta-SLaB/DSSG2017_data/sample_data/Javier/")

multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {  
  #' multiplot(): Generating multiple plots in one window  
  #'
  #' @param plotlist a number of ggplots to be aggregated
  #' @param cols the number of columns for the given ggplots when layout is not given
  #' @param layout the layout of the given ggplots (rows and columns)

  library(grid)  

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

gps <- read_delim("0722_prox_gps_join.csv", delim = ",", col_names = T)
prox <- read_delim("220717_prox.csv", delim = ",", col_names = T)
gps$id <- c(1:nrow(gps))
prox$id <- c(1:nrow(prox))

first <- gps[c(1:468),c("seq", "time", "lon", "lat", "video_time", "way", "speed", "LidarRight", "LidarLeft")]

LR <- ggplot(first, aes(x = video_time, y = LidarRight)) +
      geom_line() +
      geom_point(size = 0.5, color="red")  + 
      ylim(c(0,4000)) + scale_x_datetime(breaks=date_breaks("30 sec"), labels=date_format("%H:%M:%S")) +
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Distance (cm)") + 
      xlab("Video Time")  + ggtitle("Lidar Right (Video_time)") 

LL <- ggplot(first, aes(x = video_time, y = LidarLeft)) +
      geom_line() +
      geom_point( size = 0.5, color="red")  +
      ylim(c(0,4000))  + scale_x_datetime(breaks=date_breaks("30 sec"), labels=date_format("%H:%M:%S")) +
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Distance (cm)") + 
      xlab("Video Time")  + ggtitle("Lidar Left (Video_time)")

multiplot(LR, LL, cols=1)



# Actual riding begins at 0:02:00 in the video.
# Until 2017-07-22 03:54:38
first <- gps[c(139:468),c("seq", "time", "lon", "lat", "video_time", "way", "speed")]
second <- gps[c(474:nrow(gps)),c("seq", "time", "lon", "lat", "video_time", "way", "speed")]

prox_first <- prox[c(723:1825),]
prox_second <- prox[c(1826:nrow(prox)),]

first_join <- prox_first %>% left_join(first, by=c("time"))


#Video-time-based high-resolution graph
LR <- ggplot(first_join, aes(x = video_time)) +
      geom_line(aes(y = LidarRight), color="black") +
      geom_point(aes(y = LidarRight),size = 0.5, color="red")  +      
      ylim(c(0,9000))  + 
      scale_x_datetime(breaks=date_breaks("30 sec"), labels=date_format("%H:%M:%S")) +      
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Distance (cm)") + 
      xlab("Dummy Time (x200ms)")  + ggtitle("Lidar Right (Raw Data)") 

LL <- ggplot(first_join, aes(x = video_time)) +
      geom_line(aes(y = LidarLeft), color="black") +
      geom_point(aes(y = LidarLeft),size = 0.5, color="red")  +       
      ylim(c(0,9000))  + 
      scale_x_datetime(breaks=date_breaks("10 sec"), labels=date_format("%H:%M:%S")) +
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Distance (cm)") + 
      xlab("Dummy Time (x200ms)")  + ggtitle("Lidar Left (Raw Data)")

multiplot(LR, LL, cols=1)

# Close-up
LR <- ggplot(first_join[c(500:550),], aes(x = id)) +
      geom_line(aes(y = LidarRight), color="black") +
      geom_point(aes(y = LidarRight),size = 0.5, color="red")  + 
      geom_line(aes(y=100*(speed)), color="blue") + 
      geom_point(aes(y=100*(speed)),size = 0.5, color="blue")  +
      ylim(c(0,3000))  + 
#       scale_x_datetime(breaks=date_breaks("30 sec"), labels=date_format("%H:%M:%S")) +      
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Distance (cm)") + 
      xlab("Dummy Time (x200ms)")  + ggtitle("Lidar Right (Raw Data)") 

LL <- ggplot(first_join[c(500:550),], aes(x = id)) +
      geom_line(aes(y = LidarLeft), color="black") +
      geom_point(aes(y = LidarLeft),size = 0.5, color="red")  + 
      geom_line(aes(y=100*(speed)), color="blue") + 
      geom_point(aes(y=100*(speed)),size = 0.5, color="blue")  +
      ylim(c(0,3000))  + 
#       scale_x_datetime(breaks=date_breaks("10 sec"), labels=date_format("%H:%M:%S")) +
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Distance (cm)") + 
      xlab("Dummy Time (x200ms)")  + ggtitle("Lidar Left (Raw Data)")

multiplot(LR, LL, cols=1)

```


# Time domain to Distance domain (Value-lagging)
```{r}
first_join$dist <- 0
time_interval <- 0.2994975 #seconds

# distance intervals (just for reference)
dists <- as.vector(c(0))

for (i in c(1:nrow(first_join))){
  if (i==nrow(first_join)) break
  sp <- first_join[i,]$speed * 0.514444444 # changing the speed to meters/sec
  first_join[i+1,]$dist <- first_join[i,]$dist + (sp * time_interval)
  dists[i] <- (sp * time_interval)
}

d <- density(dists)
plot(d, main="Kernel Density of Distances per Lidar Reading")
polygon(d, col="violet")

#Distance-based plot
LR <- ggplot(first_join, aes(x = dist)) +
      geom_line(aes(y = LidarRight), color="black") +
      geom_point(aes(y = LidarRight),size = 0.5, color="red")  +      
      ylim(c(0,9000))  +       
      scale_x_continuous(breaks =seq(0, 1550, 50)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Lidar Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Lidar Right (Distance-based)") 

LL <- ggplot(first_join, aes(x = dist)) +
      geom_line(aes(y = LidarLeft), color="black") +
      geom_point(aes(y = LidarLeft),size = 0.5, color="red")  +       
      ylim(c(0,9000))  +       
      scale_x_continuous(breaks = seq(0, 1550, 50)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Lidar Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Lidar Left (Distance-based)")

multiplot(LR, LL, cols=1)


# Close-up
LR <- ggplot(first_join[c(600:650),], aes(x = dist)) +
      geom_line(aes(y = LidarRight), color="black") +
      geom_point(aes(y = LidarRight),size = 1, color="red")  +      
      ylim(c(0,2900))  +       
      scale_x_continuous(breaks =seq(775, 835, 5)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Lidar Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Lidar Right (Distance-based), Close-up") 

LL <- ggplot(first_join[c(600:650),], aes(x = dist)) +
      geom_line(aes(y = LidarLeft), color="black") +
      geom_point(aes(y = LidarLeft),size = 1, color="red")  +       
      ylim(c(0,2900))  +       
      scale_x_continuous(breaks = seq(775, 835, 5)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Lidar Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Lidar Left (Distance-based), Close-up")

multiplot(LR, LL, cols=1)

# Saving the first_join
write.table(first_join, "220717_first_part_distance_based.csv", row.names=F, col.names=T, sep=",")

```


# Naive Interpolation
```{r}

gps <- read_delim("220717_first_part_distance_based.csv", delim = ",", col_names = T)
first_join$way <- as.factor(first_join$way)

prevL <- 0
prevR <- 0

first_join$adjustedLidarLeft <- 0
first_join$adjustedLidarRight <- 0

for (i in c(1:nrow(first_join))){
  if (i==1){
    prevL <- first_join[i,]$LidarLeft
    prevR <- first_join[i,]$LidarRight
    first_join[i,]$adjustedLidarLeft <- prevL
    first_join[i,]$adjustedLidarRight <- prevR
    next
  }
  
  if (first_join[i,]$LidarLeft <= 1) {
    first_join[i,]$adjustedLidarLeft <- prevL    
  } else {    
    prevL <- first_join[i,]$LidarLeft
    first_join[i,]$adjustedLidarLeft <- prevL
  }
  
  if (first_join[i,]$LidarRight <= 1){
    first_join[i,]$adjustedLidarRight <- prevR
  } else {
    prevR <- first_join[i,]$LidarRight
    first_join[i,]$adjustedLidarRight <- prevR
  }
  
}


#Distance-based plot
LR <- ggplot(first_join, aes(x = dist)) +
      geom_line(aes(y = LidarRight), color="black") +
      geom_point(aes(y = LidarRight),size = 0.5, color="red")  +      
      geom_line(aes(y = adjustedLidarRight), color="blue") +
      geom_point(aes(y = adjustedLidarRight), size = 0.5, color="blue")  +   
      ylim(c(0,9000))  +       
      scale_x_continuous(breaks =seq(0, 1550, 50)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Lidar Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Lidar Right (Distance-based)") 

LL <- ggplot(first_join, aes(x = dist)) +
      geom_line(aes(y = LidarLeft), color="black") +
      geom_point(aes(y = LidarLeft),size = 0.5, color="red")  +    
      geom_line(aes(y = adjustedLidarLeft), color="blue") +
      geom_point(aes(y = adjustedLidarLeft), size = 0.5, color="blue")  +  
      ylim(c(0,9000))  +       
      scale_x_continuous(breaks = seq(0, 1550, 50)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Lidar Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Lidar Left (Distance-based)")

multiplot(LR, LL, cols=1)


# Close-up (car passing-by)
LR <- ggplot(first_join[c(370:410),], aes(x = dist)) +
      geom_line(aes(y = LidarRight), color="black") +
      geom_point(aes(y = LidarRight),size = 2, color="red")  +  
      geom_line(aes(y = adjustedLidarRight), color="blue") +
      geom_point(aes(y = adjustedLidarRight), size = 1, color="blue")  +   
      ylim(c(0,3200))  +       
      scale_x_continuous(breaks =seq(360, 510, 5)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Lidar Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Lidar Right (Distance-based), Close-up") 

LL <- ggplot(first_join[c(370:410),], aes(x = dist)) +
      geom_line(aes(y = LidarLeft), color="black") +
      geom_point(aes(y = LidarLeft),size = 2, color="red")  +   
      geom_line(aes(y = adjustedLidarLeft), color="blue") +
      geom_point(aes(y = adjustedLidarLeft), size = 1, color="blue")  +  
      ylim(c(0,3200))  +       
      scale_x_continuous(breaks = seq(360, 510, 5)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Lidar Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Lidar Left (Distance-based), Close-up")

multiplot(LR, LL, cols=1)

write.table(first_join, "220717_first_part_interpolated_lidars.csv", row.names=F, col.names=T, sep=",")
```


# Resampling: Adjusting data points into the regular grid (1m)
```{r}
# Given the median value of distances per lidar reading (=1.29 m), we set 1m as a unit to generate a regular-grid distance-based data
first_regular_dist <- as.data.frame(matrix(ncol=16, nrow = as.integer(max(first_join$dist))))
colnames(first_regular_dist) <- c("dist", "LidarLeft", "LidarRight", "time", "video_time", "USLeft", "USRight", "USRear", "CO", "SO", "NO", "O3", "P10", "P25", "lon", "lat")
first_regular_dist$video_time <- as.POSIXct(first_regular_dist$video_time)
attr(first_regular_dist$video_time, "tzone") <- "UTC"
first_regular_dist$time <- as.POSIXct(first_regular_dist$time)
attr(first_regular_dist$time, "tzone") <- "UTC"
resolution <- 10

for (i in c(1:nrow(first_regular_dist))){    
  print(i)
  if (max(first_join$dist) < i-1) {
    break
  }
  first_regular_dist[i,]$dist <- i - 1  
  index <- which.min(abs(first_join$dist - i + 1))
  
  if (first_join[index,]$dist <= i-1) {
    lidar_left <- (((i - 1 - first_join[index,]$dist)*(first_join[index+1,]$adjustedLidarLeft - first_join[index,]$adjustedLidarLeft)) / (first_join[index+1,]$dist - first_join[index,]$dist)) + first_join[index,]$adjustedLidarLeft
    lidar_right <- (((i - 1 - first_join[index,]$dist)*(first_join[index+1,]$adjustedLidarRight - first_join[index,]$adjustedLidarRight)) / (first_join[index+1,]$dist - first_join[index,]$dist)) + first_join[index,]$adjustedLidarRight    
    us_left <- (((i - 1 - first_join[index,]$dist)*(first_join[index+1,]$USLeft - first_join[index,]$USLeft)) / (first_join[index+1,]$dist - first_join[index,]$dist)) + first_join[index,]$USLeft
    us_right <- (((i - 1 - first_join[index,]$dist)*(first_join[index+1,]$USRight - first_join[index,]$USRight)) / (first_join[index+1,]$dist - first_join[index,]$dist)) + first_join[index,]$USRight
    us_rear <- (((i - 1 - first_join[index,]$dist)*(first_join[index+1,]$USRear - first_join[index,]$USRear)) / (first_join[index+1,]$dist - first_join[index,]$dist)) + first_join[index,]$USRear
    
    dist_rate <- resolution * (i - 1 - first_join[index,]$dist) / (first_join[index+1,]$dist - first_join[index,]$dist)
    dist_rate <- as.integer(dist_rate)
    points <- gcIntermediate(first_join[index,c("lon","lat")], first_join[index+1,c("lon","lat")], resolution-1)
        
    if (dist_rate == 0 | nrow(points) == 1){
      first_regular_dist[i,]$lat <- first_join[index,]$lat
      first_regular_dist[i,]$lon <- first_join[index,]$lon
    } else if (dist_rate == resolution) {
      first_regular_dist[i,]$lat <- first_join[index+1,]$lat
      first_regular_dist[i,]$lon <- first_join[index+1,]$lon
    } else {      
      first_regular_dist[i,]$lat <- points[dist_rate,2]
      first_regular_dist[i,]$lon <- points[dist_rate,1]
    }    
    
  } else {
    lidar_left <- (((i - 1 - first_join[index-1,]$dist)*(first_join[index,]$adjustedLidarLeft - first_join[index-1,]$adjustedLidarLeft)) / (first_join[index,]$dist - first_join[index-1,]$dist)) + first_join[index-1,]$adjustedLidarLeft
    lidar_right <- (((i - 1 - first_join[index-1,]$dist)*(first_join[index,]$adjustedLidarRight - first_join[index-1,]$adjustedLidarRight)) / (first_join[index,]$dist - first_join[index-1,]$dist)) + first_join[index-1,]$adjustedLidarRight
    us_left <- (((i - 1 - first_join[index-1,]$dist)*(first_join[index,]$USLeft - first_join[index-1,]$USLeft)) / (first_join[index,]$dist - first_join[index-1,]$dist)) + first_join[index-1,]$USLeft
    us_right <- (((i - 1 - first_join[index-1,]$dist)*(first_join[index,]$USRight - first_join[index-1,]$USRight)) / (first_join[index,]$dist - first_join[index-1,]$dist)) + first_join[index-1,]$USRight
    us_rear <- (((i - 1 - first_join[index-1,]$dist)*(first_join[index,]$USRear - first_join[index-1,]$USRear)) / (first_join[index,]$dist - first_join[index-1,]$dist)) + first_join[index-1,]$USRear
    
    dist_rate <- resolution * (i - 1 - first_join[index-1,]$dist) / (first_join[index,]$dist - first_join[index-1,]$dist)
    dist_rate <- as.integer(dist_rate)    
    points <- gcIntermediate(first_join[index-1,c("lon","lat")], first_join[index,c("lon","lat")], resolution-1)
    
    if (dist_rate == 0 | nrow(points) == 1){
      first_regular_dist[i,]$lat <- first_join[index-1,]$lat
      first_regular_dist[i,]$lon <- first_join[index-1,]$lon
    } else if (dist_rate == resolution) {
      first_regular_dist[i,]$lat <- first_join[index,]$lat
      first_regular_dist[i,]$lon <- first_join[index,]$lon
    } else {      
      first_regular_dist[i,]$lat <- points[dist_rate,2]
      first_regular_dist[i,]$lon <- points[dist_rate,1]
    }
  }
  
  first_regular_dist[i,]$LidarLeft <- lidar_left
  first_regular_dist[i,]$LidarRight <- lidar_right    
  first_regular_dist[i,]$USLeft <- us_left
  first_regular_dist[i,]$USRight <- us_right
  first_regular_dist[i,]$USRear <- us_rear
  first_regular_dist[i,]$CO <- first_join[index,]$CO  
  first_regular_dist[i,]$SO <- first_join[index,]$SO  
  first_regular_dist[i,]$O3 <- first_join[index,]$O3  
  first_regular_dist[i,]$NO <- first_join[index,]$NO  
  first_regular_dist[i,]$P10 <- first_join[index,]$P10  
  first_regular_dist[i,]$P25 <- first_join[index,]$P25  
  first_regular_dist[i,]$time <- first_join[index,]$time  
  first_regular_dist[i,]$video_time <- first_join[index,]$video_time
  
}

first_regular_dist <- first_regular_dist[!is.na(first_regular_dist$lon),]

#### gcIntermediate function test
# inter <- gcIntermediate(first_join[27,c("lon","lat")],first_join[28,c("lon","lat")], 10)
# inter <- rbind(first_join[5,c("lon","lat")], inter)
# inter <- rbind(inter, first_join[26,c("lon","lat")])
# inter$id <- c(1:nrow(inter))
# 
# map <- get_map(inter[3,], zoom = 18, source = "stamen", maptype = "toner")
# mapPoints <- ggmap(map) + geom_point(aes(x = lon, y = lat, colour=id ), data = inter, alpha = 0.9, size = 0.5) + ggtitle("gcIntermediate Test")
# mapPoints



# Close-up (random segment)
LR <- ggplot(first_join[c(50:100),], aes(x = dist)) +      
      geom_line(aes(y = adjustedLidarRight), color="black") +
      geom_point(aes(y = adjustedLidarRight), size = 1, color="red")  +         
      ylim(c(0,2600))  +       
      scale_x_continuous(breaks =seq(0, 60, 1)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Lidar Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Lidar Right (Distance-based), Close-up") 

LL <- ggplot(first_regular_dist[c(7:58),], aes(x = dist)) +      
      geom_line(aes(y = LidarRight), color="black") +
      geom_point(aes(y = LidarRight), size = 1, color="red")  +        
      ylim(c(0,2600))  +       
      scale_x_continuous(breaks = seq(0, 60, 1)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Lidar Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Lidar Right (Re-sampled), Close-up")

multiplot(LR, LL, cols=1)

# Close-up (car passing-by)
LR <- ggplot(first_join[c(370:410),], aes(x = dist)) +      
      geom_line(aes(y = adjustedLidarLeft), color="black") +
      geom_point(aes(y = adjustedLidarLeft), size = 1, color="red")  +         
      ylim(c(0,3300))  +       
      scale_x_continuous(breaks =seq(360, 500, 5)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Lidar Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Lidar Left (Distance-based), Close-up") 

LL <- ggplot(first_regular_dist[c(364:491),], aes(x = dist)) +      
      geom_line(aes(y = LidarLeft), color="black") +
      geom_point(aes(y = LidarLeft), size = 1, color="red")  +        
      ylim(c(0,3300))  +       
      scale_x_continuous(breaks = seq(360, 500, 5)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Lidar Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Lidar Left (Re-sampling), Close-up")

multiplot(LR, LL, cols=1)

map <- get_map(c(lon = mean(first_regular_dist$lon), lat = mean(first_regular_dist$lat)), zoom = 16, source = "stamen", maptype = "toner")
mapPoints <- ggmap(map) + geom_point(aes(x = lon, y = lat, color=dist), data = first_regular_dist, alpha = 0.9, size = 1) + 
  scale_colour_gradient(low = "#FFCCCC", high = "#FF0033") +
  labs(color="Time Sequence") + ggtitle("Javier, 0722, 3AM")
mapPoints



LR <- ggplot(first_regular_dist, aes(x = dist)) +      
      geom_line(aes(y = LidarRight), color="black") +
      geom_point(aes(y = LidarRight), size = 0.5, color="red")  +   
      geom_line(aes(y = USRight), color="grey") +
      geom_point(aes(y = USRight), size = 0.3, color="orange")  +      
      ylim(c(0,9000))  +       
      scale_x_continuous(breaks =seq(0, 1550, 30)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Lidar/Sonar Right (Re-sampled)") 

LL <- ggplot(first_regular_dist, aes(x = dist)) +      
      geom_line(aes(y = LidarLeft), color="black") +
      geom_point(aes(y = LidarLeft), size = 0.5, color="red")  + 
      geom_line(aes(y = USLeft), color="grey") +
      geom_point(aes(y = USLeft), size = 0.3, color="orange")  +  
      ylim(c(0,9000))  +       
      scale_x_continuous(breaks = seq(0, 1550, 30)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Lidar/Sonar Left (Re-sampled)")

multiplot(LR, LL, cols=1)


# Just for testing...
random_classifiers <- c("car", "stop-car", "parallel", "tree", "posts", "trashcan", "wall", "nothing", "people", "bike")
first_regular_dist$left_class <- sample(random_classifiers, nrow(first_regular_dist), replace = T)
first_regular_dist$right_class <- sample(random_classifiers, nrow(first_regular_dist), replace = T)

write.table(first_regular_dist, "220717_first_part_resampled_random.csv", row.names=F, col.names=T, sep=",")

```


# Smoothing Lidar and Sonar
```{r}
window <- 3
first_regular_dist$LLgaussian <- smth.gaussian(x=first_regular_dist$LidarLeft, window = window)
first_regular_dist$LRgaussian <- smth.gaussian(x=first_regular_dist$LidarRight, window = window)

# Close-up
LR <- ggplot(first_regular_dist[c(700:800),], aes(x = dist)) +      
      geom_line(aes(y = LidarRight), color="grey") +
      geom_point(aes(y = LidarRight), size = 1, color="red")  +   
      geom_line(aes(y = LRgaussian), color="black") +
      geom_point(aes(y = LRgaussian), size = 1.5, color="orange")  +      
      ylim(c(0,3000))  +       
      scale_x_continuous(breaks =seq(0, 1550, 5)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Gaussian-filtered Lidar (Right, Window_size=3)") 

LL <- ggplot(first_regular_dist[c(700:800),], aes(x = dist)) +      
      geom_line(aes(y = LidarLeft), color="grey") +
      geom_point(aes(y = LidarLeft), size = 1, color="red")  + 
      geom_line(aes(y = LLgaussian), color="black") +
      geom_point(aes(y = LLgaussian), size = 1.5, color="orange")  +  
      ylim(c(0,3000))  +       
      scale_x_continuous(breaks = seq(0, 1550, 5)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Gaussian-filtered Lidar (Left, Window_size=3)")

multiplot(LR, LL, cols=1)

# total
LR <- ggplot(first_regular_dist, aes(x = dist)) +      
      geom_line(aes(y = LidarRight), color="grey") +
      geom_point(aes(y = LidarRight), size = 0.5, color="red")  +   
      geom_line(aes(y = LRgaussian), color="black") +
      geom_point(aes(y = LRgaussian), size = 0.3, color="orange")  +      
      ylim(c(0,3000))  +       
      scale_x_continuous(breaks =seq(-10, 1600, 30)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Gaussian-filtered Lidar (Right, Window_size=3)") 

LL <- ggplot(first_regular_dist, aes(x = dist)) +      
      geom_line(aes(y = LidarLeft), color="grey") +
      geom_point(aes(y = LidarLeft), size = 0.5, color="red")  + 
      geom_line(aes(y = LLgaussian), color="black") +
      geom_point(aes(y = LLgaussian), size = 0.3, color="orange")  +  
      ylim(c(0,3000))  +       
      scale_x_continuous(breaks = seq(-10, 1600, 30)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Gaussian-filtered Lidar (Left, Window_size=3)")

multiplot(LR, LL, cols=1)


# Gaussian filtering for Sonar
window <- 3
first_regular_dist$SRgaussian <- smth.gaussian(x=first_regular_dist$USRight, window = window)
first_regular_dist$SLgaussian <- smth.gaussian(x=first_regular_dist$USLeft, window = window)

# Close-up
LR <- ggplot(first_regular_dist[c(870:970),], aes(x = dist)) +      
      geom_line(aes(y = USRight), color="grey") +
      geom_point(aes(y = USRight), size = 1, color="red")  +   
      geom_line(aes(y = SRgaussian), color="black") +
      geom_point(aes(y = SRgaussian), size = 1.5, color="orange")  +      
      ylim(c(0,800))  +       
      scale_x_continuous(breaks =seq(0, 1550, 5)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Gaussian-filtered Sonar (Right, Window_size=3)") 

LL <- ggplot(first_regular_dist[c(870:970),], aes(x = dist)) +      
      geom_line(aes(y = USLeft), color="grey") +
      geom_point(aes(y = USLeft), size = 1, color="red")  + 
      geom_line(aes(y = SLgaussian), color="black") +
      geom_point(aes(y = SLgaussian), size = 1.5, color="orange")  +  
      ylim(c(0,800))  +       
      scale_x_continuous(breaks = seq(0, 1550, 5)) + 
      theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Distance (cm)") + 
      xlab("Distance Traveled (m)")  + ggtitle("Gaussian-filtered Sonar (Left, Window_size=3)")

multiplot(LR, LL, cols=1)

write.table(first_regular_dist, "220717_first_part_gaussian.csv", row.names=F, col.names=T, sep=",")
```


# Environmental Signatures 
```{r}
first_join <- read_delim("220717_first_part_interpolated_lidars.csv", delim = ",", col_names = T)
first_regular_dist <- read_delim("220717_first_part_gaussian.csv", delim = ",", col_names = T)
sig_total <- read_delim("0722Signatures_Erica/0722_prox_gps_join.csv", delim = ",", col_names = T)
cols <- colnames(sig_total) 
cols[4] <- "left_class"
cols[5] <- "right_class"
colnames(sig_total) <- cols

sig_first <- sig_total[c(1:468),]
sig_first[is.na(sig_first$left_class),]$left_class <- "nothing"
sig_first[is.na(sig_first$right_class),]$right_class <- "nothing"
sig_first$left_class <- as.factor(sig_first$left_class)
sig_first$right_class <- as.factor(sig_first$right_class)


# function that generates an environmental signature 
# parameter: a temporal signature data frame
# return: frequency-domain signature for Lidar and Sonar (15 m)
analysis_unit <- 15
generate_left_signature <- function(temporal_sig) {
    sig_cols <- c("course", "speed", "day", "time", "lon", "lat", "seq", "way", "video_time", "USRight", "USLeft", "USRear", "LidarRight", "LidarLeft",
                  "CO", "SO", "O3", "NO", "P10", "P25")   
    colnames(temporal_sig) <- sig_cols
    sig <- first_join[first_join$seq %in% temporal_sig$seq,]
    sig <- first_regular_dist[first_regular_dist$dist >= as.integer(min(sig$dist)) & first_regular_dist$dist <= as.integer(max(sig$dist)),]
    
    if (nrow(sig) > analysis_unit) {
      gap <- as.integer((nrow(sig) - analysis_unit)/2)
      sig <- sig[c(gap:(gap+analysis_unit-1)),]
    } else {
      gap <- as.integer((analysis_unit - nrow(sig))/2)
      i = 0
      while (nrow(sig) < analysis_unit) {        
        if (i%%2 == 0){
          sig <- rbind(sig[1,], sig)
        } else {
          sig <- rbind(sig, sig[nrow(sig),])
        }
        i <- i+1        
      }      
    }
    
    sig$seq <- c(1:nrow(sig))
    
    left_lidar_sig <- dtt(sig$LidarLeft, type = c("dct"))
    left_lidar_sig <- as.data.frame(left_lidar_sig[2:length(left_lidar_sig)])
    colnames(left_lidar_sig) <- c("value")
    left_lidar_sig$sensor <- "lidar"
    
    left_sonar_sig <- dtt(sig$USLeft, type = c("dct"))
    left_sonar_sig <- as.data.frame(left_sonar_sig[2:length(left_sonar_sig)])
    colnames(left_sonar_sig) <- c("value")
    left_sonar_sig$sensor <- "sonar"
    
    left_sig <- rbind(left_lidar_sig, left_sonar_sig)
    left_sig$index <- c(1:nrow(left_sig))
    left_sig$sensor <- as.factor(left_sig$sensor)
    return (left_sig)
}

generate_right_signature <- function(temporal_sig) {
    sig_cols <- c("course", "speed", "day", "time", "lon", "lat", "seq", "way", "video_time", "USRight", "USLeft", "USRear", "LidarRight", "LidarLeft",
                  "CO", "SO", "O3", "NO", "P10", "P25")   
    colnames(temporal_sig) <- sig_cols
    sig <- first_join[first_join$seq %in% temporal_sig$seq,]
    sig <- first_regular_dist[first_regular_dist$dist >= as.integer(min(sig$dist)) & first_regular_dist$dist <= as.integer(max(sig$dist)),]
    
    if (nrow(sig) > analysis_unit) {
      gap <- as.integer((nrow(sig) - analysis_unit)/2)
      sig <- sig[c(gap:(gap+analysis_unit-1)),]
    } else {
      gap <- as.integer((analysis_unit - nrow(sig))/2)
      i = 0
      while (nrow(sig) < analysis_unit) {        
        if (i%%2 == 0){
          sig <- rbind(sig[1,], sig)
        } else {
          sig <- rbind(sig, sig[nrow(sig),])
        }
        i <- i+1        
      }      
    }
    
    sig$seq <- c(1:nrow(sig))
    
    right_lidar_sig <- dtt(sig$LidarRight, type = c("dct"))
    right_lidar_sig <- as.data.frame(right_lidar_sig[2:length(right_lidar_sig)])
    colnames(right_lidar_sig) <- c("value")
    right_lidar_sig$sensor <- "lidar"
    
    right_sonar_sig <- dtt(sig$USRight, type = c("dct"))
    right_sonar_sig <- as.data.frame(right_sonar_sig[2:length(right_sonar_sig)])
    colnames(right_sonar_sig) <- c("value")
    right_sonar_sig$sensor <- "sonar"
    
    right_sig <- rbind(right_lidar_sig, right_sonar_sig)
    right_sig$index <- c(1:nrow(right_sig))
    right_sig$sensor <- as.factor(right_sig$sensor)
    return (right_sig)
}


# Signatures (Lidar Frequency-domain Feature + Sonar Freq-domain Feature)
car <- read_delim("0722Signatures_Erica/Car LS_3.csv", delim = ",", col_names = F)
parallel <- read_delim("0722Signatures_Erica/Parallel_2.csv", delim = ",", col_names = F) # both side
tree <- read_delim("0722Signatures_Erica/Tree RS_22.csv", delim = ",", col_names = F)
car_block <- read_delim("0722Signatures_Erica/Tunnel.csv", delim = ",", col_names = F) #both
wall <- read_delim("0722Signatures_Erica/Wall RS.csv", delim = ",", col_names = F)
nothing <- read_delim("0722Signatures_Erica/Back Noise.csv", delim = ",", col_names = F) # Left
human <- read_delim("0722Signatures_Erica/Human LS.csv", delim = ",", col_names = F)
car_stop <- read_delim("0722Signatures_Erica/Car Stop RS.csv", delim = ",", col_names = F) # Right

car <- generate_left_signature(car)
parallel <- generate_right_signature(parallel)
tree <- generate_right_signature(tree)
car_block <- generate_right_signature(car_block)
wall <- generate_right_signature(wall)
nothing <- generate_left_signature(nothing)
human <- generate_right_signature(human)
car_stop <- generate_right_signature(car_stop)



## Testing
ggplot(car, aes(x = index, y = abs(value), colour=sensor)) +
  geom_line() +
  geom_point(size = 1) +  
  theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Amplitude") + 
  xlab("Frequency")  + ggtitle("Discrete Cosine Transform of the Car Signature") 

# Normalized signature (for testing)
car_left_lidar_sig$value <- scale(car_left_lidar_sig$value)
car_left_sonar_sig$value <- scale(car_left_sonar_sig$value)
car_left_sig <- rbind(car_left_lidar_sig, car_left_sonar_sig)
car_left_sig$index <- c(1:nrow(car_left_sig))
car_left_sig$sensor <- as.factor(car_left_sig$sensor)

ggplot(car_left_sig, aes(x = index, y = abs(value), colour=sensor)) +
  geom_line() +
  geom_point(size = 1) +  
  theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="Amplitude") + 
  xlab("Frequency")  + ggtitle("Discrete Cosine Transform of the Car Signature") 
```


# Classifying
```{r}

sig_total <- read_delim("0722Signatures_Erica/0722_prox_gps_join.csv", delim = ",", col_names = T)
cols <- colnames(sig_total) 
cols[4] <- "left_class"
cols[5] <- "right_class"
colnames(sig_total) <- cols

sig_total[is.na(sig_total$left_class),]$left_class <- "nothing"
sig_total[is.na(sig_total$right_class),]$right_class <- "nothing"
sig_total[sig_total$left_class=="Bench",]$left_class <- "Tree"
sig_total[sig_total$left_class=="Bike Racks",]$left_class <- "Tree"
sig_total[sig_total$left_class=="Car ",]$left_class <- "Car"
sig_total[sig_total$left_class=="Cone",]$left_class <- "Car Block"
sig_total[sig_total$left_class=="Parallel ",]$left_class <- "Parallel"
sig_total[sig_total$left_class=="Person",]$left_class <- "Human"
sig_total[sig_total$left_class=="Road Sign ",]$left_class <- "Tree"
sig_total[sig_total$left_class=="Short Post",]$left_class <- "Car Block"
sig_total[sig_total$left_class=="Sing ",]$left_class <- "Car Block"
sig_total[sig_total$left_class=="Stairs",]$left_class <- "Wall"
sig_total[sig_total$left_class=="Tree, Tunnel",]$left_class <- "Tree"
sig_total[sig_total$left_class=="Yard Wall",]$left_class <- "Wall"

sig_total[sig_total$right_class=="Bike",]$right_class <- "Tree"
sig_total[sig_total$right_class=="Mountain",]$right_class <- "Wall"
sig_total[sig_total$right_class=="Table+Chairs",]$right_class <- "Tree"
sig_total[sig_total$right_class=="Trash Can",]$right_class <- "Tree"
sig_total[sig_total$right_class=="Tree, Human",]$right_class <- "Human"
sig_total[sig_total$right_class=="Tree ,Human",]$right_class <- "Human"
sig_total[sig_total$right_class=="Person",]$right_class <- "Human"
sig_total[sig_total$right_class=="Tunnel",]$right_class <- "Car Block"
sig_total[sig_total$right_class=="Sign",]$right_class <- "Car Block"
sig_total[sig_total$right_class=="Yard Wall",]$right_class <- "Wall"
sig_total[sig_total$right_class=="Yard wall",]$right_class <- "Wall"
sig_total[sig_total$right_class=="Parallel ",]$right_class <- "Parallel"
sig_total[sig_total$right_class=="Road Sign ",]$right_class <- "Tree"

# sig_total$left_class <- as.factor(sig_total$left_class)
# sig_total$right_class <- as.factor(sig_total$right_class)

sig_total <- sig_total[,c("seq", "left_class", "right_class")]
sig_total <- first_join %>% left_join(sig_total, by=c("seq"))

first_regular_dist$left_class <- ""
first_regular_dist$right_class <- ""

for (i in c(1:nrow(first_regular_dist))){    
  print(i)
  if (max(sig_total$dist) < i-1) {
    break
  }
  
  index <- which.min(abs(sig_total$dist - i + 1))
  
  first_regular_dist[i,]$left_class <- sig_total[index,]$left_class
  first_regular_dist[i,]$right_class <- sig_total[index,]$right_class
}

first_regular_dist$left_class <- as.factor(first_regular_dist$left_class)
first_regular_dist$right_class <- as.factor(first_regular_dist$right_class)


write.table(first_regular_dist, "220717_dist_classifications.csv", row.names=F, col.names=T, sep=",")


```


# Predicting Each Segment of Distances
```{r}

left_signature <- function(sig) {
    if (nrow(sig[is.na(sig$LLgaussian),]) != 0){
      sig[is.na(sig$LLgaussian),]$LLgaussian <- mean(sig$LLgaussian, na.rm =T)
      sig[is.na(sig$SLgaussian),]$SLgaussian <- mean(sig$SLgaussian, na.rm =T)
    }
    
    if (nrow(sig) > analysis_unit) {
      gap <- as.integer((nrow(sig) - analysis_unit)/2)
      sig <- sig[c(gap:(gap+analysis_unit-1)),]
    } else {
      gap <- as.integer((analysis_unit - nrow(sig))/2)      
      i = 0
      while (nrow(sig) < analysis_unit) {        
        if (i%%2 == 0){
          sig <- rbind(sig[1,], sig)
        } else {
          sig <- rbind(sig, sig[nrow(sig),])
        }
        i <- i+1        
      }      
    }
    
    sig$seq <- c(1:nrow(sig))
    
    left_lidar_sig <- dtt(sig$LLgaussian, type = c("dct"))
    left_lidar_sig <- as.data.frame(left_lidar_sig[2:length(left_lidar_sig)])
    colnames(left_lidar_sig) <- c("value")
    left_lidar_sig$sensor <- "lidar"
    
    left_sonar_sig <- dtt(sig$SLgaussian, type = c("dct"))
    left_sonar_sig <- as.data.frame(left_sonar_sig[2:length(left_sonar_sig)])
    colnames(left_sonar_sig) <- c("value")
    left_sonar_sig$sensor <- "sonar"
    
    left_sig <- rbind(left_lidar_sig, left_sonar_sig)
    left_sig$index <- c(1:nrow(left_sig))
    left_sig$sensor <- as.factor(left_sig$sensor)
    return (left_sig)
}


#generating the ground-truth table
unit_analysis <- 15 # meters

left_table <- as.data.frame(matrix(nrow=0, ncol=31))
colnames(left_table) <- c("id", "dist", "class", paste0("f", as.character(seq(1,28,1))))



for (i in c(1:nrow(first_regular_dist))){
  print(i)
  if (i > nrow(first_regular_dist)){
    break
  }
  dist <- i-1
  
  left_table[i,]$id <- i
  left_table[i,]$dist <- dist
  
  tmp <- first_regular_dist[c(i:(dist+unit_analysis)),]
  
  classes <- tmp$left_class
#   hist <- table(classes)
    
  for (c in c("Car", "Human", "Car Stop", "Parallel" , "Wall", "Tree", "nothing" )){
    if (c %in% classes) {
      left_table[i,]$class <- c
      break
    }
  }

  left_sig <- left_signature(tmp)
    
  left_table[i,c(4:ncol(left_table))] <- left_sig$value  
  
}


left_table$class <- as.factor(left_table$class)
left_table <- left_table[complete.cases(left_table),]


# Prediction
#Baseline Model: when selecting "nothing" for everything: 0.34  

#SVM 
num_test = 20
proportion <- c(10,20,30,40,50)
rand_error_table <- matrix(NA,nrow=length(proportion),ncol=4)
colnames(rand_error_table) <- c("train", "accuracy", "error", "F1")

ii =  1
for (j in proportion){
  print(j)
  temp_table <- matrix(nrow=num_test, ncol=3)
  colnames(temp_table) <- c("accuracy", "error", "F1")
  for (i in c(1:num_test)){
    index <- 1:nrow(left_table)
    testindex <- sample(index, trunc(length(index) * j / 100 ))
    testset <- left_table[testindex,]      
    trainset <- left_table[-testindex,]
    row.names(testset) <- testset$id
    
    features <- str_c(paste0("f", as.character(seq(1,28,1))),collapse='+')   
    model <- svm (as.formula(paste("class ~", features)), data=trainset)
    pred <- predict(model, testset)
    tb <- table(pred = pred, true= testset$class )      
    performance <- c(classAgreement(tb)$diag, 1-sum(diag(tb))/sum(tb))
    
    n = sum(tb)
    nc = nrow(tb)
    diag = diag(tb)
    rowsums = apply(tb, 1, sum)
    colsums = apply(tb, 2, sum)
    precision = diag / colsums 
    recall = diag / rowsums 
    F1 <- (2 * precision * recall) / (precision + recall)
    mean_F1 <- mean(F1, na.rm = TRUE)
                        
    temp_table[i,] <- c(sum(diag)/n, 1 - sum(diag)/n, mean_F1)
  }
  temp_table <- apply(temp_table, 2, mean)         
  rand_error_table[ii,] <- c(100-proportion[ii], temp_table["accuracy"], temp_table["error"], temp_table["F1"])
  ii <- ii + 1
}


# Random Forest
rand_error_table_rf <- matrix(NA,nrow=length(proportion),ncol=4)
colnames(rand_error_table_rf) <- c("train", "accuracy", "error", "F1")

ii =  1
for (j in proportion){
  print(j)
  temp_table <- matrix(nrow=num_test, ncol=3)
  colnames(temp_table) <- c("accuracy", "error", "F1")
  for (i in c(1:num_test)){
    index <- 1:nrow(left_table)
    testindex <- sample(index, trunc(length(index) * j / 100 ))
    testset <- left_table[testindex,]      
    trainset <- left_table[-testindex,]
    row.names(testset) <- testset$id
    
    features <- str_c(paste0("f", as.character(seq(1,28,1))),collapse='+')   
    model <- randomForest (as.formula(paste("class ~", features)), data=trainset, importance=TRUE, proximity=TRUE, na.action=na.omit) 
    pred <- predict(model, testset)
    tb <- table(pred = pred, true= testset$class )      
    performance <- c(classAgreement(tb)$diag, 1-sum(diag(tb))/sum(tb))
    
    n = sum(tb)
    nc = nrow(tb)
    diag = diag(tb)
    rowsums = apply(tb, 1, sum)
    colsums = apply(tb, 2, sum)
    precision = diag / colsums 
    recall = diag / rowsums 
    F1 <- (2 * precision * recall) / (precision + recall)
    mean_F1 <- mean(F1, na.rm = TRUE)
                        
    temp_table[i,] <- c(sum(diag)/n, 1 - sum(diag)/n, mean_F1)
  }
  temp_table <- apply(temp_table, 2, mean)         
  rand_error_table_rf[ii,] <- c(90-proportion[ii], temp_table["accuracy"], temp_table["error"], temp_table["F1"])
  ii <- ii + 1
}

rand_error_table <- as.data.frame(rand_error_table)
rand_error_table <- rand_error_table[order(rand_error_table[,c("train")]),]
rand_error_table$model <- "SVN"

rand_error_table_rf <- as.data.frame(rand_error_table_rf)
rand_error_table_rf <- rand_error_table_rf[order(rand_error_table_rf[,c("train")]),]
rand_error_table_rf$train <- c(50,60,70,80,90)
rand_error_table_rf$model <- "RF"


# Baseline
rand_error_table_rd <- matrix(NA,nrow=length(proportion),ncol=4)
colnames(rand_error_table_rd) <- c("train", "accuracy", "error", "F1")

ii =  1
for (j in proportion){
  print(j)
  temp_table <- matrix(nrow=num_test, ncol=3)
  colnames(temp_table) <- c("accuracy", "error", "F1")
  for (i in c(1:num_test)){
    index <- 1:nrow(left_table)
    testindex <- sample(index, trunc(length(index) * j / 100 ))
    testset <- left_table[testindex,]      
    trainset <- left_table[-testindex,]
    row.names(testset) <- testset$id
        
    pred <- rep("nothing", nrow(testset))
    tb <- table(pred = pred, true= testset$class )      
    performance <- c(classAgreement(tb)$diag, 1-sum(diag(tb))/sum(tb))
    
    n = sum(tb)
    nc = nrow(tb)
    diag = diag(tb)
    rowsums = apply(tb, 1, sum)
    colsums = apply(tb, 2, sum)
    precision = diag / colsums 
    recall = diag / rowsums 
    F1 <- (2 * precision * recall) / (precision + recall)
    mean_F1 <- mean(F1, na.rm = TRUE)
                        
    temp_table[i,] <- c(sum(diag)/n, 1 - sum(diag)/n, mean_F1)
  }
  temp_table <- apply(temp_table, 2, mean)         
  rand_error_table_rd[ii,] <- c(90-proportion[ii], temp_table["accuracy"], temp_table["error"], temp_table["F1"])
  ii <- ii + 1
}

rand_error_table_rd <- as.data.frame(rand_error_table_rd)
rand_error_table_rd <- rand_error_table_rd[order(rand_error_table_rd[,c("train")]),]
rand_error_table_rd$train <- c(50,60,70,80,90)
rand_error_table_rd$model <- "Baseline"


agg <- rbind(rand_error_table, rand_error_table_rf, rand_error_table_rd)
agg$model <- as.factor(agg$model)



ggplot(agg, aes(x = train, colour = model)) +      
    geom_line(aes(y = F1), linetype=5) +
    geom_point(aes(y = F1), size = 3, shape=2)  + 
    ylim(c(0,0.6)) + 
    geom_line(aes(y = accuracy)) +
    geom_point(aes(y = accuracy), size = 3)  +  
    theme_bw() + theme(legend.text=element_text(size=15)) + ylab(label="F1 Score / Accuracy") + 
    labs(colour="Model") +
    xlab("Proportion of Train Set (%) ")  + ggtitle("Prediction Performance using Frequency-based Features ")



```

